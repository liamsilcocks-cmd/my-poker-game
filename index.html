<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Vegas Poker</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;background:#000;font-family:Arial,sans-serif}
#c{width:100%;height:100%;display:block;touch-action:none}
#ui{position:fixed;top:0;left:0;right:0;bottom:0;pointer-events:none;z-index:100}
#ui > *{pointer-events:auto}
#topBar{position:absolute;top:10px;left:10px;right:10px;background:rgba(0,0,0,0.7);padding:12px 18px;border-radius:8px;color:#ffd700;display:flex;justify-content:space-between;align-items:center}
#phase{font-size:16px;font-weight:bold}
#pot{font-size:20px;font-weight:bold}
#bottomBar{position:absolute;bottom:10px;left:10px;right:10px;background:rgba(0,0,0,0.7);padding:12px 18px;border-radius:8px;color:#c8a820;text-align:center}
#chips{font-size:15px;font-weight:bold;margin-bottom:8px}
#actions{display:flex;gap:8px;justify-content:center;flex-wrap:wrap}
.btn{padding:12px 24px;border-radius:6px;border:none;font-size:14px;font-weight:bold;cursor:pointer;color:#fff}
.btn-call{background:#1a7a1a}
.btn-raise{background:#7a5800}
.btn-fold{background:#7a1a1a}
#raiseAmt{width:80px;padding:8px;border-radius:4px;border:1px solid #c8a020;background:rgba(0,0,0,0.8);color:#fff;font-size:14px;text-align:center}
#msg{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.85);padding:20px 40px;border-radius:12px;color:#fff;font-size:24px;font-weight:bold;text-align:center;display:none}
#brightness{position:absolute;top:80px;right:20px;background:rgba(0,0,0,0.7);padding:10px 14px;border-radius:8px;color:#c8a820}
#brightness label{display:block;font-size:12px;margin-bottom:4px}
#brightSlider{width:120px}
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="ui">
  <div id="topBar">
    <div id="phase">PRE-FLOP</div>
    <div id="pot">POT: Â£0.00</div>
  </div>
  <div id="bottomBar">
    <div id="chips">YOUR CHIPS: Â£10.00</div>
    <div id="actions" style="display:none">
      <button class="btn btn-call" id="callBtn">CALL</button>
      <input type="number" id="raiseAmt" value="0.40" step="0.20">
      <button class="btn btn-raise" id="raiseBtn">RAISE</button>
      <button class="btn btn-fold" id="foldBtn">FOLD</button>
    </div>
  </div>
  <div id="msg"></div>
  <div id="brightness">
    <label>â˜€ Brightness</label>
    <input type="range" id="brightSlider" min="0.5" max="3.5" step="0.1" value="1.8">
  </div>
</div>

<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script>
'use strict';

// Audio
let audioCtx;
function ensureAudio(){ if(!audioCtx) audioCtx=new(window.AudioContext||window.webkitAudioContext)(); }
function snd_deal(){
  ensureAudio(); const t=audioCtx.currentTime;
  const len=Math.floor(audioCtx.sampleRate*0.12), buf=audioCtx.createBuffer(1,len,audioCtx.sampleRate), d=buf.getChannelData(0);
  for(let i=0;i<len;i++) d[i]=(Math.random()*2-1)*Math.pow(Math.sin(Math.PI*i/len),0.6);
  const src=audioCtx.createBufferSource(), bp=audioCtx.createBiquadFilter();
  bp.type='bandpass'; bp.Q.value=0.6; bp.frequency.setValueAtTime(4200,t); bp.frequency.exponentialRampToValueAtTime(1600,t+0.12);
  const g=audioCtx.createGain(); g.gain.setValueAtTime(0,t); g.gain.linearRampToValueAtTime(0.32,t+0.015); g.gain.exponentialRampToValueAtTime(0.001,t+0.12);
  src.buffer=buf; src.connect(bp); bp.connect(g); g.connect(audioCtx.destination); src.start(t);
}
function snd_flip(){
  ensureAudio(); const t=audioCtx.currentTime, b=audioCtx.createBuffer(1,Math.floor(audioCtx.sampleRate*0.055),audioCtx.sampleRate), d=b.getChannelData(0);
  for(let i=0;i<d.length;i++) d[i]=(Math.random()*2-1)*Math.pow(1-i/d.length,1.6);
  const src=audioCtx.createBufferSource(), g=audioCtx.createGain(), hp=audioCtx.createBiquadFilter();
  hp.type='highpass'; hp.frequency.value=2200; g.gain.setValueAtTime(0.38,t); g.gain.exponentialRampToValueAtTime(0.001,t+0.055);
  src.buffer=b; src.connect(hp); hp.connect(g); g.connect(audioCtx.destination); src.start(t);
}
function snd_chip(){
  ensureAudio(); const t=audioCtx.currentTime, base=1600+Math.random()*500;
  [[1.0,0.18],[1.52,0.10],[2.51,0.06],[3.97,0.03],[5.80,0.015]].forEach(([r,v])=>{
    const osc=audioCtx.createOscillator(), g=audioCtx.createGain();
    osc.type='sine'; osc.frequency.value=base*r*(0.97+Math.random()*0.06);
    g.gain.setValueAtTime(v,t); g.gain.setValueAtTime(v*0.6,t+0.003); g.gain.exponentialRampToValueAtTime(0.0001,t+0.08+r*0.025);
    osc.connect(g); g.connect(audioCtx.destination); osc.start(t); osc.stop(t+0.15);
  });
}
function snd_win(){
  ensureAudio(); const t=audioCtx.currentTime;
  [523,659,784,1047,1319].forEach((f,i)=>{
    const o=audioCtx.createOscillator(), g=audioCtx.createGain();
    o.type='triangle'; o.frequency.value=f;
    g.gain.setValueAtTime(0,t+i*0.10); g.gain.linearRampToValueAtTime(0.14,t+i*0.10+0.04); g.gain.exponentialRampToValueAtTime(0.001,t+i*0.10+0.55);
    o.connect(g); g.connect(audioCtx.destination); o.start(t+i*0.10); o.stop(t+i*0.10+0.6);
  });
}

// Constants
const SUITS=['â™ ','â™¥','â™¦','â™£'], RANKS=['2','3','4','5','6','7','8','9','10','J','Q','K','A'];
const RVAL={2:2,3:3,4:4,5:5,6:6,7:7,8:8,9:9,10:10,J:11,Q:12,K:13,A:14};
const NP=9, START_CHIPS=1000, SB=10, BB=20, TRX=5.4, TRZ=3.5, SRX=7.0, SRZ=5.2;

// Scene
const canvas=document.getElementById('c');
const engine=new BABYLON.Engine(canvas,true);
window.addEventListener('resize',()=>engine.resize());
canvas.addEventListener('click',()=>ensureAudio(),{once:true});

let scene, shadowGen, spotLight;
let cardBackMat, cardFrontMats={};
let cardPool=[], cardIdx=0;
let chipPool=[], potChips=[];

let G={
  deck:[], players:[], community:[], communityMeshes:[],
  pot:0, currentBet:BB, phase:'idle', dealerSeat:0, toAct:[], animating:false
};

function createScene(){
  scene=new BABYLON.Scene(engine);
  scene.clearColor=new BABYLON.Color4(0.015,0.01,0.025,1);
  
  // Camera
  const cam=new BABYLON.ArcRotateCamera('cam',-Math.PI/2,Math.PI/3.8,17,new BABYLON.Vector3(0,0.5,0),scene);
  cam.lowerRadiusLimit=7; cam.upperRadiusLimit=26; cam.lowerBetaLimit=0.20; cam.upperBetaLimit=1.35;
  cam.wheelPrecision=22; cam.attachControl(canvas,true);
  
  // Lights
  const h=new BABYLON.HemisphericLight('h',new BABYLON.Vector3(0,1,0),scene);
  h.intensity=0.18; h.diffuse=new BABYLON.Color3(0.50,0.45,0.60); h.groundColor=new BABYLON.Color3(0.06,0.04,0.08);
  spotLight=new BABYLON.SpotLight('sp',new BABYLON.Vector3(0,11,0),new BABYLON.Vector3(0,-1,0),Math.PI/2.2,1.5,scene);
  spotLight.intensity=1.8; spotLight.diffuse=new BABYLON.Color3(1,0.96,0.85);
  shadowGen=new BABYLON.ShadowGenerator(2048,spotLight);
  shadowGen.useBlurExponentialShadowMap=true; shadowGen.blurKernel=12;
  
  // Floor
  const f=BABYLON.MeshBuilder.CreateGround('floor',{width:44,height:44},scene);
  f.position.y=-0.22; f.receiveShadows=true;
  const fm=new BABYLON.StandardMaterial('fm',scene);
  fm.diffuseColor=new BABYLON.Color3(0.03,0.025,0.04); fm.specularColor=new BABYLON.Color3(0.25,0.12,0.32); fm.specularPower=160;
  f.material=fm;
  
  // Table
  const T=96;
  const base=BABYLON.MeshBuilder.CreateCylinder('base',{height:0.44,diameter:12,tessellation:T},scene);
  base.scaling.x=TRX/6; base.scaling.z=TRZ/6; base.position.y=-0.01;
  const bm=new BABYLON.StandardMaterial('bm',scene);
  bm.diffuseColor=new BABYLON.Color3(0.18,0.09,0.04); bm.specularColor=new BABYLON.Color3(0.5,0.32,0.10); bm.specularPower=160;
  base.material=bm;
  
  const rail=BABYLON.MeshBuilder.CreateTorus('rail',{diameter:11.4,thickness:0.38,tessellation:T,radialSegments:20},scene);
  rail.scaling.x=TRX/(11.4/2)*0.97; rail.scaling.z=TRZ/(11.4/2)*0.97; rail.position.y=0.18;
  const rm=new BABYLON.StandardMaterial('rm',scene);
  rm.diffuseColor=new BABYLON.Color3(0.72,0.54,0.08); rm.specularColor=new BABYLON.Color3(1,0.88,0.32); rm.specularPower=300;
  rm.emissiveColor=new BABYLON.Color3(0.08,0.06,0.006); rail.material=rm;
  
  const felt=BABYLON.MeshBuilder.CreateCylinder('felt',{height:0.07,diameter:10.8,tessellation:T},scene);
  felt.scaling.x=TRX/(10.8/2)*0.90; felt.scaling.z=TRZ/(10.8/2)*0.90; felt.position.y=0.22;
  const ftm=new BABYLON.StandardMaterial('ftm',scene);
  ftm.diffuseColor=new BABYLON.Color3(0.08,0.52,0.18); ftm.specularColor=new BABYLON.Color3(0.02,0.08,0.04); ftm.specularPower=8;
  felt.material=ftm; felt.receiveShadows=true;
  
  buildCardMats(); buildCardPool(); buildChipPool(); mkPlayers();
  setTimeout(startNewHand,1500);
  return scene;
}

// Card textures
function buildCardMats(){
  cardBackMat=new BABYLON.StandardMaterial('back',scene);
  cardBackMat.diffuseTexture=mkBackTex();
  cardBackMat.specularColor=new BABYLON.Color3(0.15,0.15,0.15); cardBackMat.specularPower=30; cardBackMat.backFaceCulling=false;
  for(const s of SUITS) for(const r of RANKS){
    const k=r+s, m=new BABYLON.StandardMaterial('f'+k,scene);
    m.diffuseTexture=mkFrontTex(s,r); m.specularColor=new BABYLON.Color3(0.10,0.10,0.10); m.specularPower=20; m.backFaceCulling=false;
    cardFrontMats[k]=m;
  }
}
function mkBackTex(){
  const W=256,H=384, tex=new BABYLON.DynamicTexture('bt',{width:W,height:H},scene,true), c=tex.getContext();
  const g=c.createLinearGradient(0,0,W,H); g.addColorStop(0,'#0d1b62'); g.addColorStop(1,'#05091e');
  c.fillStyle=g; c.fillRect(0,0,W,H); c.strokeStyle='#c8a020'; c.lineWidth=10; c.strokeRect(5,5,W-10,H-10);
  tex.update(); return tex;
}
function mkFrontTex(suit,rank){
  const W=256,H=384, tex=new BABYLON.DynamicTexture('ft'+rank+suit,{width:W,height:H},scene,true), c=tex.getContext();
  const isRed=suit==='â™¥'||suit==='â™¦', col=isRed?'#d00':'#000';
  c.fillStyle='#fff'; c.fillRect(0,0,W,H); c.strokeStyle='#ddd'; c.lineWidth=3; c.strokeRect(1.5,1.5,W-3,H-3);
  c.fillStyle=col; c.textAlign='left'; c.textBaseline='top';
  c.font='bold 52px Arial'; c.fillText(rank,16,12); c.font='42px Arial'; c.fillText(suit,rank==='10'?18:20,rank==='10'?68:72);
  c.save(); c.translate(W,H); c.rotate(Math.PI); c.font='bold 52px Arial'; c.fillText(rank,16,12); c.font='42px Arial'; c.fillText(suit,rank==='10'?18:20,rank==='10'?68:72); c.restore();
  if(rank==='A'){ c.font='160px Arial'; c.textAlign='center'; c.textBaseline='middle'; c.fillText(suit,W/2,H/2); }
  else if(['J','Q','K'].includes(rank)){ c.textAlign='center'; c.textBaseline='middle'; c.font='bold 120px Arial'; c.fillText(rank,W/2,H/2-20); c.font='56px Arial'; c.fillText(suit,W/2,H/2+70); }
  tex.update(); return tex;
}

// Card pool
const DECK_POS=()=>new BABYLON.Vector3(-TRX*0.76,0.32,0);
function buildCardPool(){
  for(let i=0;i<60;i++){
    const m=BABYLON.MeshBuilder.CreatePlane('card'+i,{width:0.72,height:1.02},scene);
    m.rotation.x=Math.PI/2; m.position=DECK_POS().clone(); m.material=cardBackMat; m.isVisible=false; m.renderingGroupId=1;
    shadowGen.addShadowCaster(m); cardPool.push(m);
  }
}
function nextCardMesh(){
  const m=cardPool[cardIdx%cardPool.length]; cardIdx++;
  m.position=DECK_POS().clone(); m.position.y+=0.26+cardIdx*0.001;
  m.rotation=new BABYLON.Vector3(Math.PI/2,0,0); m.scaling=new BABYLON.Vector3(1,1,1);
  m.material=cardBackMat; m.isVisible=true; return m;
}

// Chip pool
function buildChipPool(){
  const CHIP_DENOM=[{val:1,col:[0.92,0.90,0.88]},{val:5,col:[0.85,0.10,0.10]},{val:25,col:[0.10,0.62,0.16]},{val:100,col:[0.14,0.20,0.88]},{val:500,col:[0.52,0.06,0.62]}];
  for(const denom of CHIP_DENOM){
    for(let i=0;i<30;i++){
      const chip=BABYLON.MeshBuilder.CreateCylinder('chip',{height:0.068,diameter:0.32,tessellation:32},scene);
      const m=new BABYLON.StandardMaterial('cpm',scene);
      m.diffuseColor=new BABYLON.Color3(...denom.col); m.specularColor=new BABYLON.Color3(1,1,1); m.specularPower=260;
      m.emissiveColor=new BABYLON.Color3(...denom.col.map(v=>v*0.15)); chip.material=m; chip.isVisible=false; chip._dval=denom.val; chipPool.push(chip);
    }
  }
}
function getChipForVal(amount){
  const CHIP_DENOM=[{val:1,col:[0.92,0.90,0.88]},{val:5,col:[0.85,0.10,0.10]},{val:25,col:[0.10,0.62,0.16]},{val:100,col:[0.14,0.20,0.88]},{val:500,col:[0.52,0.06,0.62]}];
  const best=CHIP_DENOM.reduce((a,d)=>amount>=d.val&&d.val>a.val?d:a,CHIP_DENOM[0]);
  const avail=chipPool.filter(c=>!c.isVisible&&c._dval===best.val);
  const ch=avail.length?avail[0]:(chipPool.find(c=>!c.isVisible)||chipPool[0]); ch.isVisible=true; return ch;
}
function freeChip(c){ c.isVisible=false; }

// Players
function seatPos(i){ const a=Math.PI/2+(i/NP)*Math.PI*2; return new BABYLON.Vector3(Math.cos(a)*SRX,0.26,Math.sin(a)*SRZ); }
function cardPos(si,cn){ const a=Math.PI/2+(si/NP)*Math.PI*2, rx=TRX*0.70, rz=TRZ*0.70, pa=a+Math.PI/2, off=(cn-0.5)*0.50; return new BABYLON.Vector3(Math.cos(a)*rx+Math.cos(pa)*off,0.30+cn*0.002,Math.sin(a)*rz+Math.sin(pa)*off); }
function mkPlayers(){
  const NAMES=['YOU','Viktor','Sophia','James','Mei','Carlos','Anna','Duke','Roxy'];
  for(let i=0;i<NP;i++){
    G.players.push({seat:i,name:NAMES[i],chips:START_CHIPS,cards:[],cardMeshes:[],folded:false,bet:0,isHuman:i===0});
  }
}

// Game
function shuffle(d){ for(let i=d.length-1;i>0;i--){ const j=0|Math.random()*(i+1); [d[i],d[j]]=[d[j],d[i]]; } return d; }
function buildDeck(){ const d=[]; for(const s of SUITS) for(const r of RANKS) d.push({s,r}); return shuffle(d); }
function startNewHand(){
  if(G.animating) return; G.animating=true; setBtns(false); showMsg('');
  G.deck=buildDeck(); G.community=[]; G.pot=0; G.currentBet=BB; G.phase='preflop'; cardIdx=0;
  for(const m of cardPool){ m.isVisible=false; m.scaling.setAll(1); }
  for(const m of G.communityMeshes) m.isVisible=false; G.communityMeshes=[];
  for(const ch of potChips) freeChip(ch); potChips=[];
  for(const p of G.players){ for(const m of p.cardMeshes) m.isVisible=false; p.cards=[]; p.cardMeshes=[]; p.folded=false; p.bet=0; }
  const sb=(G.dealerSeat+1)%NP, bb=(G.dealerSeat+2)%NP;
  G.players[sb].chips-=SB; G.players[sb].bet=SB; G.players[bb].chips-=BB; G.players[bb].bet=BB; G.pot=SB+BB;
  setPhase('Pre-Flop'); refreshUI(); dealHoleCards(()=>{ G.animating=false; initBet((bb+1)%NP); });
}
function dealHoleCards(done){
  const seq=[]; for(let rd=0;rd<2;rd++) for(let i=0;i<NP;i++) seq.push(i);
  let idx=0;
  const next=()=>{
    if(idx>=seq.length){ done(); return; }
    const si=seq[idx++], p=G.players[si], card=G.deck.shift(); p.cards.push(card);
    const m=nextCardMesh(); p.cardMeshes.push(m); const tp=cardPos(si,p.cards.length-1);
    animDeal(m,tp,()=>{ snd_deal(); if(p.isHuman){ flipUp(m,cardFrontMats[card.r+card.s],()=>{ snd_flip(); setTimeout(next,90); }); } else setTimeout(next,90); });
  };
  next();
}
function initBet(startSeat){
  G.toAct=[]; for(let i=0;i<NP;i++){ const s=(startSeat+i)%NP; if(!G.players[s].folded&&G.players[s].chips>0) G.toAct.push(s); }
  doTurn();
}
function doTurn(){
  if(G.players.filter(p=>!p.folded).length<=1){ endRound(); return; }
  if(!G.toAct.length){ advPhase(); return; }
  const seat=G.toAct[0], p=G.players[seat];
  if(p.folded||p.chips===0){ G.toAct.shift(); doTurn(); return; }
  if(p.isHuman){ const ca=Math.min(G.currentBet-p.bet,p.chips); document.getElementById('callBtn').textContent=ca>0?'CALL Â£'+(ca/100).toFixed(2):'CHECK'; document.getElementById('raiseAmt').value=(BB*2/100).toFixed(2); setBtns(true); showMsg('Your turn!',0); }
  else setTimeout(()=>aiAct(seat),500+Math.random()*900);
}
function acted(seat,isRaise){
  G.toAct.shift();
  if(isRaise){ G.toAct=[]; for(let i=1;i<=NP;i++){ const s=(seat+i)%NP, p=G.players[s]; if(!p.folded&&p.chips>0&&p.bet<G.currentBet) G.toAct.push(s); } }
  setTimeout(doTurn,200);
}
function advPhase(){
  for(const p of G.players) p.bet=0; G.currentBet=0;
  const map={preflop:'flop',flop:'turn',turn:'river'};
  if(G.phase in map){ G.phase=map[G.phase]; setPhase(G.phase[0].toUpperCase()+G.phase.slice(1)); const dealers={flop:dealFlop,turn:dealTurn,river:dealRiver}; dealers[G.phase](()=>initBet((G.dealerSeat+1)%NP)); }
  else{ G.phase='showdown'; showdown(); }
}
function dealFlop(done){ dealCommunity(3,done); }
function dealTurn(done){ dealCommunity(1,done); }
function dealRiver(done){ dealCommunity(1,done); }
function dealCommunity(count, done){
  const communityPositions=[new BABYLON.Vector3(-1.64,0.305,0),new BABYLON.Vector3(-0.82,0.305,0),new BABYLON.Vector3(0,0.305,0),new BABYLON.Vector3(0.82,0.305,0),new BABYLON.Vector3(1.64,0.305,0)];
  let i=G.communityMeshes.length, end=i+count;
  const next=()=>{
    if(i>=end){ done(); return; }
    const cd=G.deck.shift(); G.community.push(cd); const m=nextCardMesh(); G.communityMeshes.push(m); const tp=communityPositions[i]; i++;
    animDeal(m,tp,()=>{ snd_deal(); flipUp(m,cardFrontMats[cd.r+cd.s],()=>{ snd_flip(); setTimeout(next,260); }); });
  };
  next();
}
function aiAct(seat){
  const p=G.players[seat]; if(p.folded){ acted(seat,false); return; }
  const str=handStrength(p.cards,G.community), ca=Math.min(G.currentBet-p.bet,p.chips), r=Math.random();
  let dec;
  if(ca===0) dec=str>0.55&&r<0.35?'raise':'check';
  else if(str>0.78) dec=r<0.55?'raise':'call';
  else if(str>0.42) dec=r<0.12?'fold':'call';
  else dec=r<0.50?'fold':'call';
  if(dec==='fold'){ p.folded=true; showMsg(`${p.name} folds`,1100); refreshUI(); setTimeout(()=>acted(seat,false),350); }
  else if(dec==='raise'&&p.chips>BB*2){ const ra=Math.min(BB*(2+Math.floor(r*3)),p.chips); p.chips-=ra; p.bet+=ra; G.pot+=ra; G.currentBet=Math.max(G.currentBet,p.bet); showMsg(`${p.name} raises Â£${(ra/100).toFixed(2)}`,1100); refreshUI(); animChips(seat,ra,()=>acted(seat,true)); }
  else if(ca>0){ p.chips-=ca; p.bet+=ca; G.pot+=ca; showMsg(`${p.name} calls`,900); refreshUI(); animChips(seat,ca,()=>acted(seat,false)); }
  else{ showMsg(`${p.name} checks`,700); setTimeout(()=>acted(seat,false),400); }
}
function showdown(){
  setPhase('Showdown'); const reveals=G.players.filter(p=>!p.folded&&!p.isHuman&&p.cardMeshes.length>0);
  let ri=0;
  const next=()=>{ if(ri>=reveals.length){ setTimeout(pickWinner,600); return; } const p=reveals[ri++]; let ci2=0; const fn=()=>{ if(ci2>=p.cardMeshes.length){ setTimeout(next,340); return; } const m=p.cardMeshes[ci2], cd=p.cards[ci2]; ci2++; flipUp(m,cardFrontMats[cd.r+cd.s],()=>{ snd_flip(); setTimeout(fn,200); }); }; fn(); };
  setTimeout(next,500);
}
function pickWinner(){
  const active=G.players.filter(p=>!p.folded); if(active.length===1){ finish(active[0],'Last player standing'); return; }
  let best=null, bestScore=-1; for(const p of active){ const sc=evalBest([...p.cards,...G.community]); if(sc>bestScore){ bestScore=sc; best=p; } }
  finish(best,handName(bestScore));
}
function finish(winner,label){
  const won=G.pot; snd_win(); showMsg(`ðŸ† ${winner.name} wins Â£${(won/100).toFixed(2)}\n${label}!`,0);
  chipsFlyToWinner(winner.seat,()=>{ winner.chips+=won; G.pot=0; refreshUI(); setTimeout(()=>{ showMsg(''); nextHand(); },4000); });
}
function nextHand(){ G.dealerSeat=(G.dealerSeat+1)%NP; for(const p of G.players) if(p.chips<=0) p.chips=START_CHIPS; setTimeout(startNewHand,700); }
function endRound(){ const a=G.players.filter(p=>!p.folded); if(a.length) finish(a[0],'Last player standing'); }

// Hand evaluation
function rv(r){ return RVAL[r]||parseInt(r)||0; }
function evalBest(cards){ const cs=combs(cards,Math.min(cards.length,5)); let best=0; for(const c of cs){ const s=score5(c); if(s>best)best=s; } return best; }
function combs(arr,k){ if(arr.length<=k) return [arr]; if(k===1) return arr.map(x=>[x]); const out=[]; for(let i=0;i<=arr.length-k;i++) for(const c of combs(arr.slice(i+1),k-1)) out.push([arr[i],...c]); return out; }
function score5(cards){
  const ranks=cards.map(c=>rv(c.r)).sort((a,b)=>b-a), suits=cards.map(c=>c.s), cnt={}; for(const r of ranks) cnt[r]=(cnt[r]||0)+1;
  const freq=Object.values(cnt).sort((a,b)=>b-a), flush=suits.every(s=>s===suits[0]), uniq=[...new Set(ranks)].sort((a,b)=>b-a);
  let straight=uniq.length>=5&&(uniq[0]-uniq[4]===4); if(!straight&&uniq[0]===14){ const low=uniq.slice(1); if(low.length>=4&&low[0]-low[3]===3&&low[3]===2) straight=true; }
  const base=ranks.reduce((a,r,i)=>a+r*Math.pow(15,4-i),0)/1e8, hi=ranks[0];
  if(flush&&straight&&hi===14) return 9+base; if(flush&&straight) return 8+base; if(freq[0]===4) return 7+base; if(freq[0]===3&&freq[1]===2) return 6+base;
  if(flush) return 5+base; if(straight) return 4+base; if(freq[0]===3) return 3+base; if(freq[0]===2&&freq[1]===2) return 2+base; if(freq[0]===2) return 1+base; return base;
}
function handName(s){ if(s>=9) return 'Royal Flush ðŸ‘‘'; if(s>=8) return 'Straight Flush'; if(s>=7) return 'Four of a Kind'; if(s>=6) return 'Full House'; if(s>=5) return 'Flush'; if(s>=4) return 'Straight'; if(s>=3) return 'Three of a Kind'; if(s>=2) return 'Two Pair'; if(s>=1) return 'One Pair'; return 'High Card'; }
function handStrength(hole,comm){ if(!hole.length) return 0.3; const vals=hole.map(c=>rv(c.r)), mx=Math.max(...vals), paired=hole.length===2&&hole[0].r===hole[1].r, suited=hole.length===2&&hole[0].s===hole[1].s; if(!comm.length){ if(paired) return 0.5+(mx/14)*0.38; if(suited&&mx>=11) return 0.56; if(mx===14) return 0.54; return 0.18+(mx/14)*0.30; } return Math.min(evalBest([...hole,...comm])/8,1.0); }

// Animations
function animDeal(mesh,target,done){ const start=mesh.position.clone(), mid=new BABYLON.Vector3((start.x+target.x)*0.5,start.y+3.0,(start.z+target.z)*0.5), a=mkAnim('position',BABYLON.Animation.ANIMATIONTYPE_VECTOR3,[{frame:0,value:start},{frame:12,value:mid},{frame:28,value:target}],'easeout'); scene.stopAnimation(mesh); mesh.animations=[a]; scene.beginAnimation(mesh,0,28,false,1.5,done||null); }
function flipUp(mesh,frontMat,done){ const a1=mkAnim('scaling.x',BABYLON.Animation.ANIMATIONTYPE_FLOAT,[{frame:0,value:1},{frame:11,value:0}],'easein'); scene.stopAnimation(mesh); mesh.animations=[a1]; scene.beginAnimation(mesh,0,11,false,1,()=>{ mesh.material=frontMat; const a2=mkAnim('scaling.x',BABYLON.Animation.ANIMATIONTYPE_FLOAT,[{frame:0,value:0},{frame:11,value:1}],'easeout'); scene.stopAnimation(mesh); mesh.animations=[a2]; scene.beginAnimation(mesh,0,11,false,1,done||null); }); }
function mkAnim(prop,type,keys,easeType){ const a=new BABYLON.Animation('an_'+prop,prop,60,type,BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT); a.setKeys(keys); const e=easeType==='easein'?new BABYLON.QuadraticEase():new BABYLON.CubicEase(); e.setEasingMode(easeType==='easein'?BABYLON.EasingFunction.EASINGMODE_EASEIN:BABYLON.EasingFunction.EASINGMODE_EASEOUT); a.setEasingFunction(e); return a; }
function animChips(seat,amount,done){ const pos=seatPos(seat), n=Math.min(Math.ceil(amount/BB),7); let rem=n; for(let i=0;i<n;i++){ const chip=getChipForVal(amount); potChips.push(chip); chip.position=pos.clone(); chip.position.y+=0.40+i*0.06; const angle=Math.random()*Math.PI*2, dr=Math.random()*0.55, target=new BABYLON.Vector3(Math.cos(angle)*dr,0.30+potChips.length*0.075,Math.sin(angle)*dr), start=chip.position.clone(), mid=new BABYLON.Vector3((start.x+target.x)*0.5,start.y+1.8,(start.z+target.z)*0.5), a=mkAnim('position',BABYLON.Animation.ANIMATIONTYPE_VECTOR3,[{frame:0,value:start},{frame:12,value:mid},{frame:24,value:target}],'easeout'); chip.animations=[a]; setTimeout(()=>{ scene.beginAnimation(chip,0,24,false,1.3,()=>{ snd_chip(); rem--; if(rem===0&&done)done(); }); },i*75); } if(n===0&&done) setTimeout(done,80); }
function chipsFlyToWinner(winSeat,done){ const wp=seatPos(winSeat); wp.y+=0.6; let rem=potChips.length; if(!rem){ if(done)done(); return; } for(const chip of potChips){ const start=chip.position.clone(), mid=new BABYLON.Vector3((start.x+wp.x)*0.5,start.y+2.2,(start.z+wp.z)*0.5), a=mkAnim('position',BABYLON.Animation.ANIMATIONTYPE_VECTOR3,[{frame:0,value:start},{frame:9,value:mid},{frame:20,value:wp}],'easein'); chip.animations=[a]; scene.beginAnimation(chip,0,20,false,1.4,()=>{ snd_chip(); freeChip(chip); rem--; if(rem===0){ potChips=[]; if(done)done(); } }); } }

// UI
function setBtns(v){ document.getElementById('actions').style.display=v?'flex':'none'; }
function setPhase(p){ document.getElementById('phase').textContent=p.toUpperCase(); }
function showMsg(m,ms=2400){ const el=document.getElementById('msg'); el.textContent=m; el.style.display=m?'block':'none'; if(ms>0) setTimeout(()=>el.style.display='none',ms); }
function refreshUI(){ const hp=G.players[0]; document.getElementById('pot').textContent='POT: Â£'+(G.pot/100).toFixed(2); document.getElementById('chips').textContent='YOUR CHIPS: Â£'+(hp.chips/100).toFixed(2); }
document.getElementById('callBtn').onclick=()=>{ ensureAudio(); setBtns(false); showMsg(''); const p=G.players[0], a=Math.min(G.currentBet-p.bet,p.chips); p.chips-=a; p.bet+=a; G.pot+=a; refreshUI(); animChips(0,a,()=>acted(0,false)); };
document.getElementById('raiseBtn').onclick=()=>{ ensureAudio(); setBtns(false); showMsg(''); const p=G.players[0], minR=BB*2, inputVal=Math.round(parseFloat(document.getElementById('raiseAmt').value)*100)||minR, r=Math.min(Math.max(inputVal,minR),p.chips); p.chips-=r; p.bet+=r; G.pot+=r; G.currentBet=Math.max(G.currentBet,p.bet); refreshUI(); animChips(0,r,()=>acted(0,true)); };
document.getElementById('foldBtn').onclick=()=>{ ensureAudio(); setBtns(false); showMsg(''); G.players[0].folded=true; refreshUI(); acted(0,false); };
document.getElementById('brightSlider').oninput=(e)=>{ if(spotLight) spotLight.intensity=parseFloat(e.target.value); };

const s=createScene();
engine.runRenderLoop(()=>s.render());
</script>
</body>
</html>
