'use strict';
const http   = require('http');
const { WebSocketServer } = require('ws');
const fs     = require('fs');
const path   = require('path');
const ftp    = require('basic-ftp');
const crypto = require('crypto'); // built-in â€” no install needed

const PORT  = process.env.PORT || 10000;
const SUITS = ['\u2660','\u2665','\u2666','\u2663'];
const RANKS = ['2','3','4','5','6','7','8','9','10','J','Q','K','A'];
const RVAL  = {'2':2,'3':3,'4':4,'5':5,'6':6,'7':7,'8':8,'9':9,'10':10,'J':11,'Q':12,'K':13,'A':14};
const NP    = 9;
const SB    = 10, BB = 20;
const START_CHIPS = 1000;
const ACTION_TIMEOUT = 15000;

// â”€â”€â”€ Logging â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const LOGS_DIR = path.join(__dirname, 'logs');
if (!fs.existsSync(LOGS_DIR)) fs.mkdirSync(LOGS_DIR, { recursive: true });

function handLogPath(roomId, handNum) {
  const ts = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
  return path.join(LOGS_DIR, `room${roomId}_hand${String(handNum).padStart(4,'0')}_${ts}.txt`);
}

function writeLog(room, line) {
  if (!room.G || !room.G.logPath) return;
  const ts = new Date().toTimeString().slice(0, 8);
  try { fs.appendFileSync(room.G.logPath, `[${ts}] ${line}\n`); } catch {}
}

// FTP upload after hand finishes
async function ftpUpload(localPath) {
  const host = process.env.FTP_HOST;
  const user = process.env.FTP_USER;
  const pass = process.env.FTP_PASS;
  const dir  = process.env.FTP_DIR || '/poker-logs';
  if (!host || !user || !pass) { console.log('FTP: env vars not set, skipping'); return; }
  const client = new ftp.Client();
  client.ftp.verbose = false;
  try {
    await client.access({ host, user, password: pass, secure: false });
    try { await client.ensureDir(dir); } catch {}
    await client.uploadFrom(localPath, `${dir}/${path.basename(localPath)}`);
    console.log('FTP: uploaded', path.basename(localPath));
  } catch (err) {
    console.error('FTP upload failed:', err.message);
  } finally {
    client.close();
  }
}

// â”€â”€â”€ HTTP server â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const server = http.createServer((req, res) => {
  if (req.url === '/' || req.url === '/index.html') {
    fs.readFile(path.join(__dirname, 'index.html'), (err, data) => {
      if (err) { res.writeHead(500); res.end('Error loading game'); return; }
      res.writeHead(200, { 'Content-Type': 'text/html' });
      res.end(data);
    });
    return;
  }
  if (req.url === '/logs') {
    let files = [];
    try { files = fs.readdirSync(LOGS_DIR).filter(f => f.endsWith('.txt')).sort().reverse(); } catch {}
    const links = files.map(f =>
      `<li><a href="/logs/download/${encodeURIComponent(f)}">${f}</a></li>`
    ).join('');
    res.writeHead(200, { 'Content-Type': 'text/html' });
    res.end(`<!DOCTYPE html><html><head><title>Logs</title>
      <style>body{font-family:monospace;background:#111;color:#aef;padding:20px}a{color:#ffd700}li{margin:4px 0}</style></head>
      <body><h2>SYFM Poker - Hand Logs (${files.length} files)</h2><ul>${links}</ul>
      <p><a href="/">Back to game</a></p></body></html>`);
    return;
  }
  const dl = req.url.match(/^\/logs\/download\/(.+)$/);
  if (dl) {
    const name = decodeURIComponent(dl[1]).replace(/[/\\]/g, '');
    const fp = path.join(LOGS_DIR, name);
    if (!fp.startsWith(LOGS_DIR) || !name.endsWith('.txt')) { res.writeHead(403); res.end(); return; }
    fs.readFile(fp, (err, data) => {
      if (err) { res.writeHead(404); res.end('Not found'); return; }
      res.writeHead(200, { 'Content-Type': 'text/plain', 'Content-Disposition': `attachment; filename="${name}"` });
      res.end(data);
    });
    return;
  }
  if (req.url && req.url.startsWith('/keepalive')) {
    const params = new URL(req.url, 'http://x').searchParams;
    const room = params.get('room') || '?';
    const hand = params.get('hand') || '?';
    const ts = new Date().toISOString();
    console.log(`[KEEPALIVE] ${ts} | Room: ${room} | Hand: ${hand}`);
    const r = rooms.get(room);
    if (r && r.G) writeLog(r, `KEEPALIVE sent by client at hand #${hand} â€” server alive at ${ts}`);
    res.writeHead(200, {'Content-Type':'text/plain','Access-Control-Allow-Origin':'*'});
    res.end('alive:'+ts);
    return;
  }
  res.writeHead(404); res.end('Not found');
});

// â”€â”€â”€ WebSocket â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const wss = new WebSocketServer({ server });
const rooms = new Map();

function getOrCreateRoom(roomId) {
  if (!rooms.has(roomId)) {
    rooms.set(roomId, {
      id: roomId, seats: Array(NP).fill(null), hostId: null,
      gameActive: false, pendingJoins: [], G: null, dealerSeat: -1,
      actionTimer: null, handNum: 0,
      paused: false, actionTimerSeat: -1, actionTimerRemaining: ACTION_TIMEOUT,
      actionTimerStarted: 0
    });
  }
  return rooms.get(roomId);
}

function send(ws, msg) {
  if (ws && ws.readyState === 1) ws.send(JSON.stringify(msg));
}

function broadcastAll(room, msg) {
  const str = JSON.stringify(msg);
  room.seats.forEach(s => { if (s?.ws?.readyState === 1) s.ws.send(str); });
}

function lobbySnapshot(room) {
  return {
    type: 'lobby', roomId: room.id, hostId: room.hostId, gameActive: room.gameActive,
    seats: room.seats.map(s => s ? { id: s.id, name: s.name, chips: s.chips, seat: s.seat } : null),
    pending: room.pendingJoins.map(p => ({ id: p.id, name: p.name }))
  };
}

function tableSnapshot(room, forId) {
  const G = room.G;
  if (!G) return { type: 'state', phase: 'idle', players: room.seats.map(() => null) };
  return {
    type: 'state', phase: G.phase, pot: G.pot, currentBet: G.currentBet,
    community: G.community, dealerSeat: room.dealerSeat,
    sbSeat: G.sbSeat, bbSeat: G.bbSeat, toActSeat: G.toAct[0] ?? null,
    players: room.seats.map(s => {
      if (!s) return null;
      // FIX #2: Only show hole cards to the owning player (or everyone at showdown)
      // Never reveal another player's cards, even during buy-back transitions
      const isOwner = s.id === forId;
      const atShowdown = G.phase === 'showdown' && !s.folded;
      const showCards = isOwner || atShowdown;
      return {
        seat: s.seat, name: s.name, chips: s.chips, bet: s.bet,
        folded: s.folded, disconnected: s.disconnected || false,
        pendingCashOut: s.pendingCashOut || false,
        voluntaryAutoFold: s.voluntaryAutoFold || false,
        spectator: s.spectator || false,
        pendingBuyBack: s.pendingBuyBack || false,
        cards: showCards ? s.cards : s.cards.map(() => 'back'),
        active: !s.sittingOut
      };
    })
  };
}

function startActionTimer(room, seat, remainingMs) {
  clearActionTimer(room);
  if (room.paused) {
    room.actionTimerSeat = seat;
    room.actionTimerRemaining = remainingMs != null ? remainingMs : ACTION_TIMEOUT;
    return;
  }
  const duration = remainingMs != null ? remainingMs : ACTION_TIMEOUT;
  room.actionTimerSeat = seat;
  room.actionTimerRemaining = duration;
  room.actionTimerStarted = Date.now();
  room.actionTimer = setTimeout(() => {
    const p = room.seats[seat];
    if (!p || p.folded || !room.G || room.G.toAct[0] !== seat) return;
    doFold(room, seat, 'timeout');
  }, duration);
}

function clearActionTimer(room) {
  if (room.actionTimer) { clearTimeout(room.actionTimer); room.actionTimer = null; }
  if (room.actionTimerStarted) {
    const elapsed = Date.now() - room.actionTimerStarted;
    room.actionTimerRemaining = Math.max(2000, (room.actionTimerRemaining || ACTION_TIMEOUT) - elapsed);
    room.actionTimerStarted = 0;
  }
}

// â”€â”€â”€ Pause / Resume â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function pauseGame(room, byName) {
  if (room.paused) return;
  room.paused = true;
  clearActionTimer(room);
  broadcastAll(room, { type: 'gamePaused', byName });
  console.log(`Room ${room.id} PAUSED by ${byName}`);
}

function resumeGame(room, byName) {
  if (!room.paused) return;
  room.paused = false;
  broadcastAll(room, { type: 'gameResumed', byName });
  if (room.G && room.actionTimerSeat >= 0 && room.G.toAct[0] === room.actionTimerSeat) {
    startActionTimer(room, room.actionTimerSeat, room.actionTimerRemaining || ACTION_TIMEOUT);
  }
  console.log(`Room ${room.id} RESUMED by ${byName}`);
}

// â”€â”€â”€ Connections â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const RECONNECT_GRACE_MS = 8000;

wss.on('connection', ws => {
  let myId = null, myRoomId = null;

  ws.on('message', raw => {
    let msg;
    try { msg = JSON.parse(raw); } catch { return; }

    switch (msg.type) {

      case 'join': {
        const rawRoom = String(msg.room || '1').replace(/\D/g, '') || '1';
        myRoomId = rawRoom.slice(0, 6);
        myId = msg.id || ('p_' + Math.random().toString(36).slice(2, 8));
        const name = (msg.name || 'Player').slice(0, 18).trim() || 'Player';
        const room = getOrCreateRoom(myRoomId);

        // â”€â”€ Reconnect â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        const existing = room.seats.find(s => s?.id === myId);
        if (existing) {
          if (existing._disconnectTimer) {
            clearTimeout(existing._disconnectTimer);
            existing._disconnectTimer = null;
          }
          if (existing.autoFold) {
            if (!room.pendingJoins.find(p => p.id === myId)) {
              room.pendingJoins.push({ ws, id: myId, name: existing.name, isRejoin: true });
            } else {
              const pj = room.pendingJoins.find(p => p.id === myId);
              if (pj) pj.ws = ws;
            }
            send(ws, { type: 'waiting', id: myId, reason: 'Waiting for host to re-admit you.' });
            const host = room.seats.find(s => s?.id === room.hostId);
            if (host?.ws?.readyState === 1) send(host.ws, { type: 'joinRequest', id: myId, name: existing.name });
            broadcastAll(room, lobbySnapshot(room));
          } else {
            existing.ws = ws;
            existing.disconnected = false;
            send(ws, { type: 'joined', id: myId, seat: existing.seat, isHost: myId === room.hostId });
            send(ws, lobbySnapshot(room));
            if (room.G) send(ws, tableSnapshot(room, myId));
            broadcastAll(room, { type: 'chat', name: 'System', text: `${existing.name} reconnected` });
          }
          return;
        }

        // â”€â”€ Brand-new player â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        const hasSeatedPlayers = room.seats.some(s => s !== null);
        if (!hasSeatedPlayers && room.pendingJoins.length === 0) {
          room.seats[0] = mkPlayer(ws, myId, name, 0);
          room.hostId = myId;
          send(ws, { type: 'joined', id: myId, seat: 0, isHost: true });
          broadcastAll(room, lobbySnapshot(room));
          return;
        }

        if (room.pendingJoins.find(p => p.id === myId)) {
          const pj = room.pendingJoins.find(p => p.id === myId);
          pj.ws = ws;
          send(ws, { type: 'waiting', id: myId });
          return;
        }

        room.pendingJoins.push({ ws, id: myId, name });
        send(ws, { type: 'waiting', id: myId });
        const host = room.seats.find(s => s?.id === room.hostId);
        if (host?.ws?.readyState === 1) send(host.ws, { type: 'joinRequest', id: myId, name });
        break;
      }

      case 'approve': {
        const room = rooms.get(myRoomId);
        if (!room || myId !== room.hostId) return;
        const idx = room.pendingJoins.findIndex(p => p.id === msg.id);
        if (idx === -1) return;
        const p = room.pendingJoins.splice(idx, 1)[0];

        if (msg.accept) {
          const existSeat = room.seats.find(s => s?.id === p.id);
          if (existSeat) {
            if (existSeat._disconnectTimer) {
              clearTimeout(existSeat._disconnectTimer);
              existSeat._disconnectTimer = null;
            }
            existSeat.ws = p.ws;
            existSeat.disconnected = false;
            existSeat.autoFold = false;
            send(p.ws, { type: 'joined', id: p.id, seat: existSeat.seat, isHost: p.id === room.hostId });
            send(p.ws, lobbySnapshot(room));
            if (room.G) send(p.ws, tableSnapshot(room, p.id));
            broadcastAll(room, { type: 'chat', name: 'System', text: `${existSeat.name} re-admitted to the table` });
          } else {
            const seat = room.seats.findIndex(s => s === null);
            if (seat === -1) {
              send(p.ws, { type: 'rejected', reason: 'Table is full' });
              broadcastAll(room, lobbySnapshot(room));
              return;
            }
            room.seats[seat] = mkPlayer(p.ws, p.id, p.name, seat);
            send(p.ws, { type: 'joined', id: p.id, seat, isHost: false });
            if (room.gameActive) {
              room.seats[seat].sittingOut = true;
              send(p.ws, { type: 'sittingOut', reason: 'Hand in progress - you will join next hand.' });
              send(p.ws, tableSnapshot(room, p.id));
            }
          }
        } else {
          send(p.ws, { type: 'rejected', reason: 'Host declined your request' });
        }
        broadcastAll(room, lobbySnapshot(room));
        break;
      }

      case 'startGame': {
        const room = rooms.get(myRoomId);
        if (!room || myId !== room.hostId) return;
        const playable = room.seats.filter(s => s && !s.autoFold);
        if (playable.length < 2) { send(ws, { type: 'error', msg: 'Need at least 2 players' }); return; }
        room.gameActive = true;
        broadcastAll(room, { type: 'gameStarting' });
        broadcastAll(room, lobbySnapshot(room));
        startNewHand(room);
        break;
      }

      case 'pause': {
        const room = rooms.get(myRoomId);
        if (!room || !room.gameActive) return;
        const p = room.seats.find(s => s?.id === myId);
        if (!p) return;
        pauseGame(room, p.name);
        break;
      }

      case 'resume': {
        const room = rooms.get(myRoomId);
        if (!room || !room.gameActive) return;
        const p = room.seats.find(s => s?.id === myId);
        if (!p) return;
        resumeGame(room, p.name);
        break;
      }

      // FIX #5: buyBack works for any number of players (no player-count restriction)
      case 'buyBack': {
        const room = rooms.get(myRoomId);
        if (!room) return;
        const p = room.seats.find(s => s?.id === myId);
        if (!p || !p.pendingBuyBack) return;

        if (p._buyBackTimer) { clearTimeout(p._buyBackTimer); p._buyBackTimer = null; }

        if (msg.accept) {
          p.chips = START_CHIPS;
          p.pendingBuyBack = false;
          p.spectator = false;
          // FIX buy-back mid-hand: keep sittingOut=true so they don't
          // receive action prompts for the current hand in progress.
          // startNewHand() resets sittingOut to false for everyone at hand start.
          p.sittingOut = true;
          writeLog(room, `BUY-BACK: ${p.name} has bought back in for Â£${(START_CHIPS/100).toFixed(2)} â€” will join next hand`);
          broadcastAll(room, { type: 'chat', name: 'System', text: `${p.name} has bought back in for Â£${(START_CHIPS/100).toFixed(2)} â€” joining next hand!` });
          send(p.ws, { type: 'buyBackAccepted', chips: START_CHIPS });
        } else {
          p.pendingBuyBack = false;
          p.sittingOut = true;
          p.spectator = true;
          writeLog(room, `SPECTATOR: ${p.name} declined buy-back â€” watching as spectator`);
          broadcastAll(room, { type: 'chat', name: 'System', text: `${p.name} is now spectating.` });
          send(p.ws, { type: 'spectating' });
        }
        broadcastState(room);
        break;
      }

      case 'voluntaryAutoFold': {
        const room = rooms.get(myRoomId);
        if (!room) return;
        const p = room.seats.find(s => s?.id === myId);
        if (!p) return;
        p.voluntaryAutoFold = msg.enabled === true;
        writeLog(room, `AUTO-FOLD ${p.voluntaryAutoFold ? 'ON' : 'OFF'}: ${p.name} ${p.voluntaryAutoFold ? 'has enabled auto-fold â€” will fold every hand' : 'has turned auto-fold OFF and is back in the game'}`);
        if (p.voluntaryAutoFold && room.G && room.G.toAct[0] === p.seat) {
          clearActionTimer(room);
          doFold(room, p.seat, 'auto-fold');
        }
        // Acknowledge the toggle
        send(ws, { type: 'voluntaryAutoFoldAck', enabled: p.voluntaryAutoFold });
        break;
      }

      case 'action': {
        const room = rooms.get(myRoomId);
        if (!room?.G || !room.gameActive) return;
        const actSeat = room.seats.findIndex(s => s?.id === myId);
        if (actSeat === -1 || room.G.toAct[0] !== actSeat) return;
        clearActionTimer(room);
        handleAction(room, actSeat, msg.action, msg.amount);
        break;
      }

      case 'cashOut': {
        const room = rooms.get(myRoomId);
        if (!room) return;
        const s = room.seats.find(s => s?.id === myId);
        if (!s) return;

        const inActiveHand = room.G && !s.folded && !s.sittingOut &&
          room.G.phase !== 'idle' && s.cards && s.cards.length > 0;

        if (inActiveHand) {
          s.pendingCashOut = true;
          send(ws, { type: 'cashOutPending' });
          broadcastAll(room, { type: 'chat', name: 'System', text: `${s.name} will cash out after this hand` });
          writeLog(room, `CASH OUT PENDING: ${s.name} (Seat ${s.seat+1}) requested cash-out mid-hand â€” will be processed at hand end | Stack: Â£${(s.chips/100).toFixed(2)}`);
          if (room.G.toAct[0] === s.seat) {
            clearActionTimer(room);
            doFold(room, s.seat, 'cash out');
          } else if (!s.folded) {
            s.folded = true;
            const idx = room.G.toAct.indexOf(s.seat);
            if (idx !== -1) room.G.toAct.splice(idx, 1);
            broadcastAll(room, { type: 'playerAction', seat: s.seat, action: 'fold', amount: 0, name: s.name + ' (cashing out)' });
            writeLog(room, `FOLD (cash out): ${s.name}`);
            broadcastState(room);
            checkRoundEnd(room);
          }
          broadcastState(room);
        } else {
          executeCashOut(room, s);
        }
        break;
      }

      case 'chat': {
        const room = rooms.get(myRoomId);
        if (!room) return;
        const s = room.seats.find(s => s?.id === myId);
        if (!s) return;
        broadcastAll(room, { type: 'chat', name: s.name, text: (msg.text || '').slice(0, 120) });
        break;
      }
    }
  });

  ws.on('close', () => {
    if (!myId || !myRoomId) return;
    const room = rooms.get(myRoomId);
    if (!room) return;

    const pi = room.pendingJoins.findIndex(p => p.id === myId && p.ws === ws);
    if (pi !== -1) {
      room.pendingJoins.splice(pi, 1);
      broadcastAll(room, lobbySnapshot(room));
      return;
    }

    const s = room.seats.find(s => s?.id === myId);
    if (!s) return;
    if (s.ws !== ws) return;

    s.disconnected = true;
    s.ws = null;
    broadcastAll(room, { type: 'chat', name: 'System', text: `${s.name} disconnected â€” reconnecting...` });
    writeLog(room, `DISCONNECT: ${s.name} (Seat ${s.seat+1}) left â€” ${RECONNECT_GRACE_MS/1000}s grace period started | Stack: Â£${(s.chips/100).toFixed(2)}`);
    broadcastState(room);

    if (room.G && room.G.toAct[0] === s.seat) {
      clearActionTimer(room);
      doFold(room, s.seat, 'disconnected');
    }

    s._disconnectTimer = setTimeout(() => {
      if (!s.disconnected || s.ws !== null) return;
      s.autoFold = true;
      s._disconnectTimer = null;
      broadcastAll(room, { type: 'chat', name: 'System', text: `${s.name} timed out â€” auto-folding until host re-admits` });
      writeLog(room, `TIMEOUT: ${s.name} (Seat ${s.seat+1}) failed to reconnect â€” auto-fold enabled | Stack: Â£${(s.chips/100).toFixed(2)}`);

      if (room.G && !s.folded) {
        s.folded = true;
        const idx = room.G.toAct.indexOf(s.seat);
        if (idx !== -1) room.G.toAct.splice(idx, 1);
        broadcastAll(room, { type: 'playerAction', seat: s.seat, action: 'fold', amount: 0, name: s.name + ' (timed out)' });
        broadcastState(room);
        checkRoundEnd(room);
      }

      if (room.hostId) {
        const host = room.seats.find(h => h?.id === room.hostId);
        if (host?.ws?.readyState === 1) {
          send(host.ws, { type: 'joinRequest', id: s.id, name: s.name });
        }
      }
    }, RECONNECT_GRACE_MS);
  });

  ws.on('error', err => console.error('WS error:', err.message));
});

// â”€â”€â”€ Execute an immediate cash-out for a player â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function executeCashOut(room, s) {
  const chips = s.chips;
  const seatIdx = s.seat;
  const logMsg = `CASH OUT: ${s.name} (Seat ${seatIdx+1}) leaves with Â£${(chips/100).toFixed(2)}`;
  console.log(logMsg);
  if (room.G) writeLog(room, logMsg);

  broadcastAll(room, { type: 'chat', name: 'System', text: `${s.name} has cashed out with Â£${(chips/100).toFixed(2)}` });
  broadcastAll(room, { type: 'playerLeft', id: s.id, name: s.name, seat: seatIdx, reason: 'cashout' });

  room.seats[seatIdx] = null;

  if (room.hostId === s.id) {
    const newHost = room.seats.find(Boolean);
    if (newHost) {
      room.hostId = newHost.id;
      send(newHost.ws, { type: 'chat', name: 'System', text: 'You are now the host.' });
    }
  }
  broadcastAll(room, lobbySnapshot(room));
  broadcastState(room);
}

function mkPlayer(ws, id, name, seat) {
  return {
    ws, id, name, chips: START_CHIPS, seat, cards: [], bet: 0,
    folded: false, disconnected: false, autoFold: false,
    pendingCashOut: false, _disconnectTimer: null
  };
}

// â”€â”€â”€ Game helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Cryptographically secure Fisher-Yates shuffle using Node's crypto.randomInt.
// crypto.randomInt(min, max) draws from the OS CSPRNG â€” unpredictable even if
// the process state is somehow observed, unlike Math.random().
function shuffle(d) {
  for (let i = d.length - 1; i > 0; i--) {
    const j = crypto.randomInt(0, i + 1);
    [d[i], d[j]] = [d[j], d[i]];
  }
  return d;
}
function buildDeck() {
  const d = [];
  for (const s of SUITS) for (const r of RANKS) d.push({ s, r });
  return shuffle(d);
}

// FIX #3 / #2: activePlaying must exclude spectators, pendingBuyBack, and 0-chip players
function activePlaying(room) {
  return room.seats
    .map((s, i) => {
      if (!s) return null;
      if (s.sittingOut) return null;
      if (s.autoFold) return null;
      if (s.spectator) return null;
      if (s.pendingBuyBack) return null;
      if (s.chips <= 0) return null;
      return i;
    })
    .filter(i => i !== null);
}

function nextSeat(from, active) {
  const sorted = [...active].sort((a, b) => a - b);
  const nxt = sorted.find(i => i > from);
  return nxt !== undefined ? nxt : sorted[0];
}

// FIX #3 & #4: buildActOrder â€” properly tracks who still needs to act.
// The "toAct" list should contain every non-folded player with chips who hasn't
// yet matched the current bet OR has not yet had a chance to act this street.
function buildActOrder(room, startSeat, active) {
  const sorted = [...active].sort((a, b) => a - b);
  let startIdx = sorted.indexOf(startSeat);
  if (startIdx === -1) startIdx = 0;
  // Rotate so startSeat is first
  const ordered = [...sorted.slice(startIdx), ...sorted.slice(0, startIdx)];
  return ordered.filter(i => {
    const p = room.seats[i];
    return p && !p.folded && !p.autoFold && !p.voluntaryAutoFold && p.chips > 0;
  });
}

// FIX #3: Count players who can actually make a meaningful decision.
// A player who is all-in cannot act further but is still "in" the hand.
function canActCount(room) {
  if (!room.G) return 0;
  return room.seats.filter(s =>
    s && !s.folded && !s.sittingOut && !s.spectator && !s.pendingBuyBack &&
    s.chips > 0
  ).length;
}

// Helper: check if round should end due to one or zero real players remaining unfolded.
// autoFold/voluntaryAutoFold players don't count â€” they'll be folded automatically.
function checkRoundEnd(room) {
  const alive = room.seats.filter(s =>
    s && !s.folded && !s.sittingOut && !s.spectator && !s.pendingBuyBack &&
    !s.autoFold && !s.voluntaryAutoFold
  );
  if (alive.length <= 1) {
    endRound(room);
    return true;
  }
  return false;
}

// â”€â”€â”€ Hand flow â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function startNewHand(room) {
  clearActionTimer(room);

  if (room.paused) {
    room.paused = false;
    broadcastAll(room, { type: 'gameResumed' });
  }
  room.actionTimerSeat = -1;
  room.actionTimerRemaining = ACTION_TIMEOUT;
  room.actionTimerStarted = 0;

  // Process any pending cash-outs from the previous hand
  room.seats.forEach((s, i) => {
    if (s && s.pendingCashOut) {
      executeCashOut(room, s);
    }
  });

  room.seats.forEach(s => {
    if (s) {
      s.sittingOut = false;
      if (s._disconnectTimer) { clearTimeout(s._disconnectTimer); s._disconnectTimer = null; }
    }
  });

  const active = activePlaying(room);

  if (active.length < 2) {
    broadcastAll(room, { type: 'waitingForPlayers' });
    room.gameActive = false;
    broadcastAll(room, lobbySnapshot(room));
    return;
  }

  room.dealerSeat = room.dealerSeat < 0
    ? active[0]
    : nextSeat(room.dealerSeat, active);

  room.handNum = (room.handNum || 0) + 1;

  const isHeadsUp = active.length === 2;
  // Heads-up: dealer posts SB and acts first preflop; BB acts first postflop
  const sbSeat = isHeadsUp ? room.dealerSeat : nextSeat(room.dealerSeat, active);
  const bbSeat = nextSeat(sbSeat, active);
  const preflopStart = nextSeat(bbSeat, active);

  const logPath = handLogPath(room.id, room.handNum);

  room.G = {
    deck: buildDeck(), phase: 'preflop', pot: 0,
    currentBet: BB,
    lastRaiseIncrement: BB,
    community: [], toAct: [], sbSeat, bbSeat, isHeadsUp, logPath
  };

  room.seats.forEach(s => { if (s) { s.cards = []; s.bet = 0; s.folded = false; } });

  const dealStartSeat = isHeadsUp ? bbSeat : sbSeat;
  const dsIdx = active.indexOf(dealStartSeat);
  const dealOrder = dsIdx >= 0
    ? [...active.slice(dsIdx), ...active.slice(0, dsIdx)]
    : active;

  const now = new Date();
  const dateStr = now.toLocaleDateString('en-GB', {weekday:'long',year:'numeric',month:'long',day:'numeric'});
  const timeStr = now.toLocaleTimeString('en-GB', {hour:'2-digit',minute:'2-digit',second:'2-digit'});
  const totalChips = active.reduce((s,i) => s + room.seats[i].chips, 0);
  const playerLines = active.map(i => {
    const s = room.seats[i];
    const tags = [];
    if (i === room.dealerSeat) tags.push('DEALER');
    if (i === sbSeat) tags.push('SB');
    if (i === bbSeat) tags.push('BB');
    return `  Seat ${String(i+1).padStart(2)} | ${s.name.padEnd(18)} | Stack: Â£${(s.chips/100).toFixed(2).padStart(7)} ${tags.length?'['+tags.join('+')+']':''}`;
  }).join('\n');

  fs.writeFileSync(logPath,
    'â•”' + 'â•'.repeat(62) + 'â•—\n' +
    'â•‘  SYFM POKER â€” HAND LOG' + ' '.repeat(39) + 'â•‘\n' +
    'â• ' + 'â•'.repeat(62) + 'â•£\n' +
    `â•‘  Room: ${room.id.padEnd(10)} Hand: #${String(room.handNum).padEnd(6)} Date: ${dateStr.slice(0,20).padEnd(20)}â•‘\n` +
    `â•‘  Time: ${timeStr.padEnd(54)}â•‘\n` +
    'â• ' + 'â•'.repeat(62) + 'â•£\n' +
    'â•‘  PLAYERS AT THE TABLE' + ' '.repeat(40) + 'â•‘\n' +
    'â• ' + 'â•'.repeat(62) + 'â•£\n' +
    playerLines.split('\n').map(l => 'â•‘' + l.padEnd(63) + 'â•‘').join('\n') + '\n' +
    'â• ' + 'â•'.repeat(62) + 'â•£\n' +
    `â•‘  Format: ${isHeadsUp ? 'HEADS-UP' : active.length+'-handed'} | Blinds: SB Â£${(SB/100).toFixed(2)} / BB Â£${(BB/100).toFixed(2)} | Total chips in play: Â£${(totalChips/100).toFixed(2)}`.padEnd(63) + 'â•‘\n' +
    `â•‘  Deal order: ${dealOrder.map(i=>room.seats[i].name).join(' â†’ ')}`.padEnd(63) + 'â•‘\n' +
    'â•š' + 'â•'.repeat(62) + 'â•\n\n'
  );

  room.seats[sbSeat].chips -= SB; room.seats[sbSeat].bet = SB;
  room.seats[bbSeat].chips -= BB; room.seats[bbSeat].bet = BB;
  room.G.pot = SB + BB;

  // FIX #2: Cards are dealt ONLY to active players â€” no other seat gets cards
  for (let rd = 0; rd < 2; rd++)
    for (const si of dealOrder)
      room.seats[si].cards.push(room.G.deck.shift());

  writeLog(room, 'â”Œâ”€ HOLE CARDS DEALT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”');
  dealOrder.forEach(i => {
    const s = room.seats[i];
    const tags = [];
    if (i === room.dealerSeat) tags.push('D');
    if (i === sbSeat) tags.push('SB');
    if (i === bbSeat) tags.push('BB');
    const tagStr = tags.length ? ' ['+tags.join('+')+']' : '';
    writeLog(room, `â”‚ ${('Seat '+(i+1)+' '+s.name).padEnd(22)}${tagStr.padEnd(8)}: ${s.cards.map(c=>c.r+c.s).join('  ')} â”‚`);
  });
  writeLog(room, 'â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜');

  // FIX #4: Pre-flop act order â€” starts AFTER the BB.
  // BB player is allowed to raise even if no one else has raised (option).
  // We build the full rotation; the BB will appear at the END so they get their option.
  room.G.toAct = buildActOrder(room, preflopStart, active);

  broadcastAll(room, {
    type: 'newHand', dealerSeat: room.dealerSeat, sbSeat, bbSeat,
    pot: room.G.pot, activeSeats: dealOrder
  });

  // FIX #2: Send each player ONLY their own cards via individual tableSnapshot
  room.seats.forEach(s => {
    if (s?.ws?.readyState === 1) send(s.ws, tableSnapshot(room, s.id));
  });

  writeLog(room, '');
  writeLog(room, 'â”Œâ”€ PREFLOP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”');
  writeLog(room, `â”‚  Pot (blinds): Â£${((room.G.pot)/100).toFixed(2).padEnd(44)}â”‚`);
  writeLog(room, `â”‚  SB: ${room.seats[sbSeat].name.padEnd(18)} posts Â£${(SB/100).toFixed(2).padEnd(30)}â”‚`);
  writeLog(room, `â”‚  BB: ${room.seats[bbSeat].name.padEnd(18)} posts Â£${(BB/100).toFixed(2).padEnd(30)}â”‚`);
  writeLog(room, `â”‚  Act order: ${room.G.toAct.map(i=>room.seats[i].name).join(' â†’ ').padEnd(49)}â”‚`);
  writeLog(room, 'â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜');
  promptToAct(room);
}

// FIX #3 & #4: promptToAct â€” the core of the "wrong player asked" and
// "check after bet" bugs. This function now correctly:
// 1. Skips auto-fold/disconnected/0-chip players
// 2. Ends the street when no one is left to act (not by accident)
// 3. Detects when only 1 player can act and skips to showdown/next street
function promptToAct(room) {
  const G = room.G;
  if (!G) return;

  // Clean up toAct list: remove players who can no longer act
  while (G.toAct.length) {
    const si = G.toAct[0];
    const p = room.seats[si];
    if (!p || p.folded || p.autoFold || p.voluntaryAutoFold || p.chips === 0) {
      G.toAct.shift();
    } else {
      break;
    }
  }

  // Count players genuinely still in the hand (not folded, not sitting out,
  // not spectating, not pending buy-back, and NOT on autoFold/voluntaryAutoFold).
  // autoFold players are effectively gone from this hand â€” they will fold immediately.
  const activeInHand = room.seats.filter(s =>
    s && !s.folded && !s.sittingOut && !s.spectator && !s.pendingBuyBack &&
    !s.autoFold && !s.voluntaryAutoFold
  );

  // If 1 or fewer real players remain, end the round â€” no point asking anyone
  if (activeInHand.length <= 1) {
    // First auto-fold anyone left in toAct who is on autoFold so the fold logs correctly
    const toAutoFold = room.seats.filter(s =>
      s && !s.folded && !s.sittingOut && !s.spectator && !s.pendingBuyBack &&
      (s.autoFold || s.voluntaryAutoFold)
    );
    if (toAutoFold.length > 0) {
      // Fold them silently then end
      for (const af of toAutoFold) {
        if (!af.folded) {
          af.folded = true;
          const label = af.voluntaryAutoFold ? 'auto-fold' : 'auto (disconnected)';
          broadcastAll(room, { type: 'playerAction', seat: af.seat, action: 'fold', amount: 0, name: af.name + ` (${label})` });
          writeLog(room, `FOLD   | ${af.name.padEnd(18)} | auto-fold â€” no other active players`);
          const idx = G.toAct.indexOf(af.seat);
          if (idx !== -1) G.toAct.splice(idx, 1);
        }
      }
      broadcastState(room);
    }
    endRound(room);
    return;
  }

  // Count unfolded players still in the hand (regardless of chips) â€” for all-in detection
  const unfolded = room.seats.filter(s =>
    s && !s.folded && !s.sittingOut && !s.spectator && !s.pendingBuyBack &&
    !s.autoFold && !s.voluntaryAutoFold
  );

  // FIX #3: Count players who CAN still act (have chips and aren't all-in)
  const canAct = unfolded.filter(s => s.chips > 0);

  // If nobody can act (all remaining are all-in), run the board automatically
  if (canAct.length === 0 || G.toAct.length === 0) {
    advPhase(room);
    return;
  }

  // FIX #3: If only 1 player can still act and all others are all-in,
  // skip asking them if their bet is already matched â€” just run the board.
  if (canAct.length === 1 && G.toAct.length > 0) {
    const soloSeat = G.toAct[0];
    const solo = room.seats[soloSeat];
    if (solo) {
      const callAmt = Math.min(G.currentBet - solo.bet, solo.chips);
      if (callAmt === 0) {
        const othersAllIn = unfolded.filter(s => s.seat !== soloSeat && s.chips === 0);
        if (othersAllIn.length === unfolded.length - 1) {
          advPhase(room);
          return;
        }
      }
    }
  }

  const seat = G.toAct[0];
  const p = room.seats[seat];

  if (!p) { G.toAct.shift(); setTimeout(() => promptToAct(room), 100); return; }

  // Auto-fold disconnected / auto-fold flagged players immediately
  if (p.disconnected || p.autoFold || p.voluntaryAutoFold) {
    clearActionTimer(room);
    const reason = p.voluntaryAutoFold ? 'auto-fold' : 'auto (disconnected)';
    doFold(room, seat, reason);
    return;
  }

  // FIX #4: Determine if this is a check (no bet to call) or call situation
  const callAmt  = Math.min(G.currentBet - p.bet, p.chips);
  const minRaise = Math.min(callAmt + G.lastRaiseIncrement, p.chips);

  // firstBet = no one has bet yet this street (so button says BET not RAISE)
  const firstBet = G.currentBet === 0;

  broadcastAll(room, {
    type: 'yourTurn',
    seat,
    callAmt,         // 0 = check, >0 = amount to call
    minRaise,
    pot: G.pot,
    currentBet: G.currentBet,
    firstBet        // true = "BET", false = "RAISE"
  });
  startActionTimer(room, seat);
}

function doFold(room, seat, reason) {
  const p = room.seats[seat];
  if (!p) return;
  p.folded = true;
  const label = reason ? ` (${reason})` : '';
  broadcastAll(room, { type: 'playerAction', seat, action: 'fold', amount: 0, name: p.name + label });
  writeLog(room, `FOLD   | ${p.name.padEnd(18)} | Pot: Â£${((room.G?.pot||0)/100).toFixed(2)} | Players still in: ${room.seats.filter(s=>s&&!s.folded).length}${label?'  ('+label.trim()+')':''}`);
  // Remove from toAct
  if (room.G) {
    const idx = room.G.toAct.indexOf(seat);
    if (idx !== -1) room.G.toAct.splice(idx, 1);
  }
  broadcastState(room);

  // Check if round should end immediately
  if (!checkRoundEnd(room)) {
    // Round continues â€” but if only one player can still act and toAct has more,
    // still need to prompt the next player
    setTimeout(() => promptToAct(room), 200);
  }
}

// FIX #4: handleAction â€” betting logic corrected
// The key bug was: after a raise, we were not correctly rebuilding toAct
// to include only players who still need to call the new amount.
function handleAction(room, seat, action, amount) {
  const p = room.seats[seat];
  const G = room.G;
  if (!p || !G) return;

  if (action === 'fold') {
    doFold(room, seat, null);

  } else if (action === 'check' || action === 'call') {
    // FIX #4: Correctly handle check vs call
    const ca = Math.min(G.currentBet - p.bet, p.chips);
    p.chips -= ca; p.bet += ca; G.pot += ca;

    // Determine if this was actually a check or call
    const act = ca === 0 ? 'check' : 'call';
    broadcastAll(room, { type: 'playerAction', seat, action: act, amount: ca, name: p.name, pot: G.pot });
    writeLog(room, `${act==='check'?'CHECK ':'CALL  '} | ${p.name.padEnd(18)} | Amount: ${ca>0?'Â£'+(ca/100).toFixed(2).padStart(7):'  ---   '} | Stack after: Â£${(p.chips/100).toFixed(2)} | Pot: Â£${(G.pot/100).toFixed(2)}`);
    broadcastState(room);

    // Remove from toAct and advance
    G.toAct.shift();
    setTimeout(() => promptToAct(room), 200);

  } else if (action === 'raise') {
    // FIX #4: Raise logic â€” rebuild toAct properly after a raise
    const callAmount     = G.currentBet - p.bet;           // what they must call first
    const minFromStack   = Math.min(callAmount + G.lastRaiseIncrement, p.chips);
    const raiseFromStack = Math.min(Math.max(amount || minFromStack, minFromStack), p.chips);

    const prevCurrentBet = G.currentBet;
    p.chips -= raiseFromStack;
    p.bet   += raiseFromStack;
    G.pot   += raiseFromStack;

    // New street-level bet ceiling
    G.currentBet = Math.max(G.currentBet, p.bet);

    // Track raise increment for min-raise calculation
    if (G.currentBet > prevCurrentBet) {
      G.lastRaiseIncrement = G.currentBet - prevCurrentBet;
    }

    broadcastAll(room, { type: 'playerAction', seat, action: 'raise', amount: raiseFromStack, name: p.name, pot: G.pot });
    writeLog(room,
      `RAISE  | ${p.name.padEnd(18)} | Amount: Â£${(raiseFromStack/100).toFixed(2).padStart(7)} | Total bet: Â£${(p.bet/100).toFixed(2)} | ` +
      `New street bet: Â£${(G.currentBet/100).toFixed(2)} | Stack after: Â£${(p.chips/100).toFixed(2)} | Pot: Â£${(G.pot/100).toFixed(2)}`
    );
    broadcastState(room);

    // FIX #4: After a raise, rebuild toAct to include ALL remaining active players
    // who haven't yet matched the new currentBet â€” rotating from the player AFTER the raiser.
    const active = activePlaying(room).sort((a, b) => a - b);

    // Build a rotation starting from the seat AFTER the raiser
    const raiserIdx = active.indexOf(seat);
    const rotated = raiserIdx >= 0
      ? [...active.slice(raiserIdx + 1), ...active.slice(0, raiserIdx + 1)]
      : active;

    // Include every active player who:
    // - hasn't folded
    // - has chips
    // - has NOT yet matched the new currentBet (or is the raiser themselves, excluded since they just acted)
    G.toAct = rotated.filter(i => {
      if (i === seat) return false; // raiser doesn't act again unless re-raised
      const op = room.seats[i];
      return op && !op.folded && !op.autoFold && !op.voluntaryAutoFold && op.chips > 0 && op.bet < G.currentBet;
    });

    setTimeout(() => promptToAct(room), 200);
  }
}

function broadcastState(room) {
  room.seats.forEach(s => { if (s?.ws?.readyState === 1) send(s.ws, tableSnapshot(room, s.id)); });
}

function advPhase(room) {
  const G = room.G;
  clearActionTimer(room);
  room.seats.forEach(s => { if (s) s.bet = 0; });
  G.currentBet = 0;
  G.lastRaiseIncrement = BB;

  const next = { preflop: 'flop', flop: 'turn', turn: 'river' };

  if (G.phase in next) {
    G.phase = next[G.phase];
    const count = G.phase === 'flop' ? 3 : 1;
    const newCards = [];
    for (let i = 0; i < count; i++) { const c = G.deck.shift(); G.community.push(c); newCards.push(c); }

    broadcastAll(room, { type: 'communityDealt', phase: G.phase, cards: G.community, newCards });
    writeLog(room, '');
    writeLog(room, 'â”Œâ”€ ' + G.phase.toUpperCase().padEnd(10) + 'â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”');
    writeLog(room, 'â”‚  New cards : ' + newCards.map(c=>c.r+c.s).join('  ').padEnd(47) + 'â”‚');
    writeLog(room, 'â”‚  Board     : ' + G.community.map(c=>c.r+c.s).join('  ').padEnd(47) + 'â”‚');
    writeLog(room, 'â”‚  Pot       : Â£' + (G.pot/100).toFixed(2).padEnd(46) + 'â”‚');
    writeLog(room, 'â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜');
    broadcastState(room);

    const active = activePlaying(room);

    // FIX #3: After dealing community cards, check if anyone can actually act.
    // Exclude autoFold/voluntaryAutoFold players â€” they are effectively out.
    const unfolded = room.seats.filter(s =>
      s && !s.folded && !s.sittingOut && !s.spectator && !s.pendingBuyBack &&
      !s.autoFold && !s.voluntaryAutoFold
    );

    if (unfolded.length <= 1) {
      endRound(room);
      return;
    }

    // Players who can still bet/call (have chips)
    const canAct = active.filter(i => {
      const p = room.seats[i];
      return p && !p.folded && p.chips > 0;
    });

    if (canAct.length <= 1 && G.phase !== 'river') {
      // All remaining players are all-in â€” run board automatically without asking
      writeLog(room, `â”‚  All players all-in â€” running board automatically     â”‚`);
      setTimeout(() => advPhase(room), 1200);
      return;
    }

    // FIX #3: If only 1 player can act but others are all-in, still run board
    // (no meaningful betting can happen with 1 active vs all-in opponents)
    if (canAct.length <= 1) {
      // We're at the river with no meaningful action possible
      setTimeout(() => {
        G.phase = 'showdown';
        showdown(room);
      }, 1200);
      return;
    }

    // Post-flop act order: starts left of dealer (SB position in normal play)
    const postStart = G.isHeadsUp ? G.bbSeat : nextSeat(room.dealerSeat, active);
    G.toAct = buildActOrder(room, postStart, active);
    writeLog(room, `Act order: ${G.toAct.map(i => room.seats[i].name).join(' â†’ ')}`);
    setTimeout(() => promptToAct(room), 600);

  } else {
    G.phase = 'showdown';
    showdown(room);
  }
}

function endRound(room) {
  clearActionTimer(room);
  // Remaining = unfolded players who are genuinely still playing (not autoFold)
  const remaining = room.seats.filter(s =>
    s && !s.folded && !s.sittingOut && !s.spectator && !s.pendingBuyBack &&
    !s.autoFold && !s.voluntaryAutoFold
  );
  if (remaining.length === 1) {
    writeLog(room, `RESULT: ${remaining[0].name} wins uncontested`);
    finish(room, [remaining[0]], 'Last player standing');
  } else if (remaining.length === 0) {
    writeLog(room, `RESULT: No eligible winner found â€” hand skipped`);
    setTimeout(() => startNewHand(room), 3000);
  }
}

function showdown(room) {
  clearActionTimer(room);
  const active = room.seats.filter(s =>
    s && !s.folded && !s.sittingOut && !s.spectator && !s.pendingBuyBack
  );
  if (active.length === 1) {
    writeLog(room, `RESULT: ${active[0].name} wins at showdown uncontested`);
    finish(room, [active[0]], 'Last player standing');
    return;
  }
  if (active.length === 0) {
    writeLog(room, `RESULT: No players at showdown â€” hand skipped`);
    setTimeout(() => startNewHand(room), 3000);
    return;
  }

  broadcastAll(room, { type: 'showdown', reveals: active.map(s => ({ seat: s.seat, name: s.name, cards: s.cards })) });
  broadcastState(room);

  writeLog(room, '');
  writeLog(room, 'â•”' + 'â•'.repeat(62) + 'â•—');
  writeLog(room, 'â•‘  SHOWDOWN' + ' '.repeat(52) + 'â•‘');
  writeLog(room, 'â• ' + 'â•'.repeat(62) + 'â•£');
  writeLog(room, `â•‘  Board: ${room.G.community.map(c=>c.r+c.s).join('  ').padEnd(53)}â•‘`);
  writeLog(room, 'â• ' + 'â•'.repeat(62) + 'â•£');

  let bestScore = -1;
  const scored = active.map(p => {
    const allCards = [...p.cards, ...room.G.community];
    const sc = evalBest(allCards);
    const bf = bestFiveCards(allCards);
    if (sc > bestScore) bestScore = sc;
    return { p, sc, bf };
  });

  for (const { p, sc, bf } of scored) {
    const holeStr = p.cards.map(c=>c.r+c.s).join(' ');
    const bestStr = bf.map(c=>c.r+c.s).join(' ');
    const hn = handName(sc);
    writeLog(room, `â•‘  ${('Seat '+(p.seat+1)+' '+p.name).padEnd(22)} | Hole: ${holeStr.padEnd(10)} | Best: ${bestStr.padEnd(14)} | ${hn.padEnd(16)}â•‘`);
  }

  const winners = scored.filter(({ sc }) => sc === bestScore).map(({ p }) => p);
  const winHandName = handName(bestScore);

  writeLog(room, 'â• ' + 'â•'.repeat(62) + 'â•£');
  if (winners.length === 1) {
    writeLog(room, `â•‘  ğŸ† WINNER: ${winners[0].name} with ${winHandName}`.padEnd(63) + 'â•‘');
  } else {
    writeLog(room, `â•‘  ğŸ¤ SPLIT POT: ${winners.map(w=>w.name).join(' & ')} â€” ${winHandName}`.padEnd(63) + 'â•‘');
  }
  writeLog(room, 'â•š' + 'â•'.repeat(62) + 'â•');

  setTimeout(() => finish(room, winners, winHandName), 1200);
}

function finish(room, winners, label) {
  if (!winners || winners.length === 0) return;
  clearActionTimer(room);

  const pot = room.G.pot;
  room.G.pot = 0;

  if (winners.length === 1) {
    const winner = winners[0];
    winner.chips += pot;
    broadcastAll(room, { type: 'winner', seat: winner.seat, name: winner.name, amount: pot, label });
    broadcastState(room);
    writeLog(room, '');
    writeLog(room, 'â”Œâ”€ HAND RESULT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”');
    writeLog(room, `â”‚  ${winner.name} wins Â£${(pot/100).toFixed(2)} (${label})`.padEnd(63) + 'â”‚');
  } else {
    const perPlayer  = Math.floor(pot / winners.length);
    const remainder  = pot - perPlayer * winners.length;
    const sorted     = [...winners].sort((a, b) => a.seat - b.seat);

    sorted.forEach((w, i) => {
      const share = perPlayer + (i === 0 ? remainder : 0);
      w.chips += share;
    });

    const names  = sorted.map(w => w.name).join(' & ');
    const shares = sorted.map(w => `Â£${(perPlayer/100).toFixed(2)}`).join(' / ');

    sorted.forEach((w, i) => {
      const share = perPlayer + (i === 0 ? remainder : 0);
      broadcastAll(room, {
        type: 'winner',
        seat: w.seat,
        name: w.name,
        amount: share,
        label: `Split pot â€” ${label}`
      });
    });

    broadcastState(room);
    writeLog(room, '');
    writeLog(room, 'â”Œâ”€ HAND RESULT (SPLIT POT) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”');
    writeLog(room, `â”‚  ğŸ¤ ${names} split Â£${(pot/100).toFixed(2)} (${label})`.padEnd(63) + 'â”‚');
    writeLog(room, `â”‚  Each receives: ${shares}`.padEnd(63) + 'â”‚');
    if (remainder > 0) {
      writeLog(room, `â”‚  Odd chip (Â£${(remainder/100).toFixed(2)}) goes to ${sorted[0].name} (earliest seat)`.padEnd(63) + 'â”‚');
    }
  }

  writeLog(room, 'â”œâ”€ CHIP COUNTS AFTER HAND â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤');
  room.seats.filter(Boolean).sort((a,b) => b.chips - a.chips).forEach(s => {
    const bar  = 'â–ˆ'.repeat(Math.round(s.chips / START_CHIPS * 20));
    const note = s.pendingCashOut ? ' [CASHING OUT]' : '';
    writeLog(room, `â”‚  ${('Seat '+(s.seat+1)+' '+s.name).padEnd(22)} Â£${(s.chips/100).toFixed(2).padStart(7)}  ${bar}${note}`.padEnd(63) + 'â”‚');
  });
  writeLog(room, 'â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜');
  writeLog(room, '');

  const logPath = room.G.logPath;
  if (logPath) setTimeout(() => ftpUpload(logPath), 500);

  setTimeout(() => {
    // FIX #5: Offer buy-back to any busted player regardless of player count
    room.seats.forEach((s, i) => {
      if (s && s.chips <= 0 && !s.pendingBuyBack && !s.spectator) {
        s.pendingBuyBack = true;
        s.sittingOut = true;
        writeLog(room, `BUST: ${s.name} (Seat ${i+1}) is out of chips â€” offering buy-back (15s)`);
        broadcastAll(room, { type: 'chat', name: 'System', text: `${s.name} is out of chips!` });
        send(s.ws, { type: 'buyBackOffer', chips: START_CHIPS });

        s._buyBackTimer = setTimeout(() => {
          if (!s.pendingBuyBack) return;
          s.pendingBuyBack = false;
          s.sittingOut = true;
          s.spectator = true;
          writeLog(room, `SPECTATOR (timeout): ${s.name} did not respond â€” now spectating`);
          broadcastAll(room, { type: 'chat', name: 'System', text: `${s.name} is now spectating.` });
          send(s.ws, { type: 'spectating' });
          broadcastState(room);
        }, 15000);
      }
    });

    startNewHand(room);
  }, 5000);
}

// â”€â”€â”€ Hand evaluator â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function rv(r) { return RVAL[r] || parseInt(r) || 0; }

function evalBest(cards) {
  const cs = combs(cards, Math.min(cards.length, 5));
  let best = -1;
  for (const c of cs) { const s = score5(c); if (s > best) best = s; }
  return best;
}

function bestFiveCards(cards) {
  const cs = combs(cards, Math.min(cards.length, 5));
  let best = -1, bestCombo = cards.slice(0, 5);
  for (const c of cs) { const s = score5(c); if (s > best) { best = s; bestCombo = c; } }
  return bestCombo;
}

function combs(arr, k) {
  if (arr.length <= k) return [arr];
  if (k === 1) return arr.map(x => [x]);
  const out = [];
  for (let i = 0; i <= arr.length - k; i++)
    for (const c of combs(arr.slice(i + 1), k - 1)) out.push([arr[i], ...c]);
  return out;
}

function score5(cards) {
  const sorted = [...cards].sort((a, b) => rv(b.r) - rv(a.r));
  const ranks  = sorted.map(c => rv(c.r));
  const suits  = sorted.map(c => c.s);

  const cnt = {};
  for (const r of ranks) cnt[r] = (cnt[r] || 0) + 1;
  const groups = Object.entries(cnt)
    .map(([r, n]) => ({ r: Number(r), n }))
    .sort((a, b) => b.n - a.n || b.r - a.r);
  const tbRanks = groups.flatMap(g => Array(g.n).fill(g.r));

  const flush = suits.every(s => s === suits[0]);
  const uniq  = [...new Set(ranks)].sort((a, b) => b - a);

  let isStraight = false, sHigh = 0;
  if (uniq.length === 5) {
    if (uniq[0] - uniq[4] === 4) {
      isStraight = true; sHigh = uniq[0];
    } else if (uniq[0] === 14 && uniq[1] === 5 && uniq[2] === 4 && uniq[3] === 3 && uniq[4] === 2) {
      isStraight = true; sHigh = 5;
    }
  }

  const pack = rArr => rArr.reduce((acc, r, i) => acc + r * Math.pow(15, 4 - i), 0);
  const freq = groups[0].n, freq2 = groups[1]?.n || 0;

  if (flush && isStraight && sHigh === 14) return 9e8 + pack(ranks);
  if (flush && isStraight)                  return 8e8 + sHigh * 1e6;
  if (freq === 4)                           return 7e8 + pack(tbRanks);
  if (freq === 3 && freq2 === 2)            return 6e8 + pack(tbRanks);
  if (flush)                                return 5e8 + pack(ranks);
  if (isStraight)                           return 4e8 + sHigh * 1e6;
  if (freq === 3)                           return 3e8 + pack(tbRanks);
  if (freq === 2 && freq2 === 2)            return 2e8 + pack(tbRanks);
  if (freq === 2)                           return 1e8 + pack(tbRanks);
  return pack(ranks);
}

function handName(s) {
  if (s >= 9e8) return 'Royal Flush';
  if (s >= 8e8) return 'Straight Flush';
  if (s >= 7e8) return 'Four of a Kind';
  if (s >= 6e8) return 'Full House';
  if (s >= 5e8) return 'Flush';
  if (s >= 4e8) return 'Straight';
  if (s >= 3e8) return 'Three of a Kind';
  if (s >= 2e8) return 'Two Pair';
  if (s >= 1e8) return 'One Pair';
  return 'High Card';
}

// â”€â”€â”€ Start â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
server.listen(PORT, () => {
  console.log(`\nâ™£ SYFM Poker running on port ${PORT}`);
  console.log(`   Game: http://localhost:${PORT}`);
  console.log(`   Logs: http://localhost:${PORT}/logs`);
  console.log(`   FTP:  ${process.env.FTP_HOST || '(not configured)'}\n`);
});
